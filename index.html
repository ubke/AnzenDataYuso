<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Secure Memo Transfer</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        /* LINE風 UIデザイン */
        :root {
            --bg-color: #7289DA; /* ディスコードとLINEの中間のような色 */
            --chat-bg: #85a0e6;
            --msg-bg-me: #8de055;
            --text-color: #333;
        }
        body { margin: 0; font-family: sans-serif; background-color: var(--chat-bg); height: 100vh; display: flex; flex-direction: column; }
        
        /* ヘッダー */
        header { background-color: #5d72a8; color: white; padding: 15px; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { margin: 0; font-size: 18px; }
        
        /* チャットエリア */
        #chat-container { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 10px; }
        
        /* --- メッセージのレイアウト（LINE風：横並び） --- */
        /* 1つのメッセージの行（時間＋吹き出しを横に並べる） */
        .message-row {
            display: flex;
            justify-content: flex-end; /* 右寄せ */
            align-items: flex-end;     /* 下揃え */
            margin-bottom: 10px;       /* 次のメッセージとの間隔 */
            width: 100%;
        }

        /* 吹き出し本体 */
        .message-bubble {
            max-width: 70%;            /* 吹き出しの最大幅（少し狭める） */
            padding: 10px 15px;
            border-radius: 15px;
            font-size: 16px;
            line-height: 1.4;
            position: relative;
            word-break: break-all;
            
            /* 緑色のスタイル */
            background-color: var(--msg-bg-me);
            color: var(--text-color);
            border-bottom-right-radius: 2px; /* 右下の角だけ尖らせる */
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        /* 画像のスタイル調整 */
        .message-bubble img { 
            max-width: 100%; 
            border-radius: 10px; 
            display: block; 
            cursor: pointer; 
        }

        /* 時刻表示（吹き出しの左・外側に配置） */
        .timestamp {
            font-size: 10px;
            color: rgba(0,0,0,0.6);
            margin-right: 6px;  /* 吹き出しとの隙間 */
            margin-bottom: 2px; /* 下端の微調整 */
            flex-shrink: 0;     /* 時間が潰れないようにする */
            white-space: nowrap; /* 改行させない */
        }
        
        .message img { max-width: 100%; border-radius: 10px; display: block; margin-top: 5px; cursor: pointer; }
        
        /* 入力エリア */
        #input-area { background: white; padding: 10px; display: flex; align-items: center; gap: 10px; border-top: 1px solid #ddd; }
        #message-input { flex: 1; padding: 12px; border-radius: 20px; border: 1px solid #ddd; outline: none; font-size: 16px; }
        #file-btn, #send-btn { background: none; border: none; cursor: pointer; color: #5d72a8; }
        #file-input { display: none; }

        /* 認証・設定モーダル */
        #auth-modal { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0,0,0,0.8); 
            
            /* 【変更】最初は隠しておく！ */
            display: none; 
            
            justify-content: center; 
            align-items: center; 
            z-index: 1000; 
        }
        .modal-content { background: white; padding: 25px; border-radius: 10px; width: 90%; max-width: 350px; text-align: center; }
        .modal-content input { width: 100%; padding: 10px; margin: 10px 0; box-sizing: border-box; }
        .modal-content button { width: 100%; padding: 12px; background: #5d72a8; color: white; border: none; border-radius: 5px; font-size: 16px; cursor: pointer; }
        .hidden { display: none !important; }

        /* 画像グリッドのスタイル */
        .image-grid {
            display: grid;
            gap: 2px;
            border-radius: 12px;
            overflow: hidden;
            width: 100%;
            max-width: 300px; /* バカでかくならないように制限 */
        }
        
        /* 枚数ごとのレイアウト定義 */
        .image-grid[data-count="1"] { grid-template-columns: 1fr; }
        .image-grid[data-count="2"] { grid-template-columns: 1fr 1fr; }
        .image-grid[data-count="3"] { grid-template-columns: 1fr 1fr 1fr; }
        .image-grid[data-count="4"] { grid-template-columns: 1fr 1fr; } /* 2x2 */
        
        /* 5枚以上は3列 */
        .image-grid[data-count="5"], .image-grid[data-count="6"], 
        .image-grid[data-count="7"], .image-grid[data-count="8"], 
        .image-grid[data-count="9"] { 
            grid-template-columns: repeat(3, 1fr); 
        }

        .image-grid img, .image-grid video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            aspect-ratio: 1 / 1; /* 正方形にする */
            display: block;
        }
        
        /* 1枚だけの時は正方形強制を解除 */
        .image-grid[data-count="1"] img, .image-grid[data-count="1"] video {
            aspect-ratio: auto;
            max-height: 400px;
        }

        /* ロード画面のスタイル */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #85a0e6; /* チャット背景と同じ色 */
            display: none; /* 最初はJSで制御するのでnoneにしておく */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* ログイン画面より手前 */
            color: white;
            font-weight: bold;
        }

        /* クルクル回るスピナー */
        .loader {
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top: 5px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- 追加：時刻表示のスタイル --- */
        .timestamp {
            display: block;          /* 改行して配置 */
            font-size: 10px;         /* 文字はかなり小さく */
            color: rgba(0,0,0,0.5);  /* 薄い黒色 */
            text-align: right;       /* 右寄せ */
            margin-top: 4px;         /* 画像や文字との隙間 */
            line-height: 1;          /* 行間を詰める */
        }
        
        /* 画像だけの場合は、画像の上に重ならないように少し調整 */
        .message .image-grid + .timestamp {
            margin-top: 6px;
        }
        
        /* モーダル内の画像にタッチ操作の設定を追加 */
        #modal-img {
            /* 既存のスタイル */
            max-width: 95%;
            max-height: 95%;
            object-fit: contain;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            
            /* 【追加】ここから下を追加してください */
            touch-action: none; /* ブラウザのデフォルト操作を無効化 */
            transform-origin: center center; /* 真ん中を中心に拡大 */
            transition: transform 0.1s ease-out; /* 動きを滑らかに */
        }

        /* モーダルの戻るボタン */
        #modal-back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 32px;       /* 大きくて押しやすく */
            padding: 12px;         /* タップ判定を広く */
            background: rgba(0, 0, 0, 0.5); /* 半透明の黒背景 */
            border-radius: 50%;    /* 丸くする */
            cursor: pointer;
            z-index: 10001;        /* 画像より手前に表示 */
            user-select: none;     /* 文字選択させない */
        }
        
        /* ボタンを押した時のリアクション */
        #modal-back-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        /* 背景の黒い幕に対する設定（裏側への貫通防止） */
        #image-modal {
            touch-action: none;
        }

        /* --- 画像プレビューとD&Dのスタイル --- */
        
        /* プレビューエリア（入力欄の上に表示） */
        #preview-area {
            display: flex;
            gap: 10px;
            padding: 0 10px;    /* 画像がある時だけ余白が出るようにJSで制御、またはmin-height */
            background: #f5f5f5;
            overflow-x: auto;   /* 横スクロール */
            border-top: 1px solid #ddd;
        }
        
        /* 画像が1枚もない時は隠す */
        #preview-area:empty {
            display: none;
            padding: 0;
            border: none;
        }

        /* サムネイルの枠 */
        .preview-item {
            position: relative;
            width: 60px;
            height: 60px;
            margin: 10px 0;
            border-radius: 5px;
            overflow: hidden;
            flex-shrink: 0;
            border: 1px solid #ccc;
            background: white;
        }

        .preview-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 削除ボタン（×） */
        .preview-remove {
            position: absolute;
            top: 0;
            right: 0;
            background: rgba(0,0,0,0.6);
            color: white;
            font-size: 14px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        /* ドラッグしてファイルを持ってきた時のハイライト */
        #input-area.dragover {
            background-color: #e0e7ff; /* 薄い青色 */
            border-top: 2px solid #5d72a8;
        }
        
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loader"></div>
        <p>ロード中...</p> </div>

    <div id="auth-modal">
        <div class="modal-content">
            <h2>セキュリティ設定</h2>
            <p>このパスワードが暗号化キーになります。<br>忘れるとデータは復元できません。</p>
            <input type="email" id="email" placeholder="メールアドレス（ID代わり）">
            <input type="password" id="password" placeholder="ログインパスワード">
            <input type="password" id="encryption-key" placeholder="データ暗号化キー（必須）">
            <button onclick="login()">ログイン / 新規登録して開始</button>
        </div>
    </div>

    <header>
        <h1>anzen datA YUSO</h1>
        <button onclick="logout()" style="background: transparent; border: 1px solid white; color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 14px;">
            ログアウト
        </button>
    </header>

    <div id="chat-container"></div>

    <div id="preview-area"></div>

    <div id="input-area">
        <label for="file-input" id="file-btn">
            <span class="material-icons" style="font-size: 30px;">add_photo_alternate</span>
        </label>
        <input type="file" id="file-input" accept="image/*,video/*" multiple onchange="handleFileSelect(this)">
        
        <input type="text" id="message-input" placeholder="メモを入力..." onkeypress="handleKeyPress(event)">
        
        <button id="send-btn" onclick="sendMessage()">
            <span class="material-icons" style="font-size: 30px;">send</span>
        </button>
    </div>

    <div id="image-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 9999; justify-content: center; align-items: center;">
        <span id="modal-back-btn" class="material-icons" onclick="closeModal()">arrow_back</span>
        
        <img id="modal-img" style="max-width: 95%; max-height: 95%; object-fit: contain; box-shadow: 0 0 20px rgba(0,0,0,0.5);">
    </div>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

    <script>
        // 【重要】ここにFirebase設定を貼り付ける
        // Firebase Console -> Project Settings -> General -> Your apps -> Config
        const firebaseConfig = {
            apiKey: "AIzaSyAST5jRP6cftYUHCb5MAtHr_H7SSht8mwA",
            authDomain: "anzendatayuso.firebaseapp.com",
            projectId: "anzendatayuso",
            storageBucket: "anzendatayuso.firebasestorage.app",
            messagingSenderId: "438096878174",
            appId: "1:438096878174:web:0c1867708a48af90ceb2cf"
        };

        // Firebase初期化
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.firestore();
        const auth = firebase.auth();
        let currentUser = null;
        let secretKey = ""; // ユーザーが入力した暗号化キー

        // --- 暗号化・復号化ロジック (AES) ---
        // サーバーにはこの関数を通した「意味不明な文字列」しか保存されません
        function encryptData(data) {
            return CryptoJS.AES.encrypt(data, secretKey).toString();
        }

        function decryptData(ciphertext) {
            try {
                const bytes = CryptoJS.AES.decrypt(ciphertext, secretKey);
                return bytes.toString(CryptoJS.enc.Utf8);
            } catch (e) {
                return null; // 復号失敗（キーが違うなど）
            }
        }

        // --- ログイン処理 ---
        function login() {
            const email = document.getElementById('email').value;
            const pass = document.getElementById('password').value;
            const key = document.getElementById('encryption-key').value;

            if (!email || !pass || !key) {
                alert("全ての項目を入力してください");
                return;
            }

            // 【追加】ここで鍵をブラウザに保存してしまう
            localStorage.setItem('savedKey', key); 
            secretKey = key; 

            // まずログインを試みる
            auth.signInWithEmailAndPassword(email, pass)
                .then((userCredential) => {
                    initApp(userCredential.user);
                })
                .catch((error) => {
                    // エラー処理（前回と同じロジック）
                    const errorCode = error.code;
                    if (errorCode === 'auth/user-not-found' || 
                        errorCode === 'auth/invalid-login-credentials' || 
                        errorCode === 'auth/invalid-credential') {
                        
                        auth.createUserWithEmailAndPassword(email, pass)
                            .then((userCredential) => {
                                initApp(userCredential.user);
                            })
                            .catch((createError) => {
                                if (createError.code === 'auth/email-already-in-use') {
                                    alert("パスワードが間違っています。");
                                } else if (createError.code === 'auth/weak-password') {
                                    alert("パスワードは6文字以上にしてください。");
                                } else {
                                    alert("登録エラー: " + createError.message);
                                }
                            });
                    } else {
                        alert("ログインエラー: " + error.message);
                    }
                });
        }

        function initApp(user) {
            currentUser = user;
            document.getElementById('auth-modal').classList.add('hidden');
            loadMessages();
        }

        function logout() {
            // ログアウト時は保存した鍵も消去する
            localStorage.removeItem('savedKey');
            auth.signOut();
            location.reload();
        }

        // --- メッセージ送信（複数枚セット対応版） ---
        async function sendMessage(textInput = null, imagesInput = null) {
            // テキストボックスの値を取得（引数がなければ）
            const input = document.getElementById('message-input');
            const text = textInput !== null ? textInput : input.value;
            
            // 画像配列の準備
            let images = [];
            if (imagesInput) {
                // 配列ならそのまま、単体なら配列にする（互換性のため）
                images = Array.isArray(imagesInput) ? imagesInput : [imagesInput];
            }

            if (!text && images.length === 0) return;

            const sendBtn = document.getElementById('send-btn');
            sendBtn.disabled = true;
            sendBtn.style.opacity = "0.5";

            try {
                // ペイロード作成（images配列を保存）
                const payload = {
                    text: text,
                    images: images, // ここに複数枚入る
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };

                // 暗号化・分割保存ロジック（変更なし、そのまま利用）
                const encryptedContent = encryptData(JSON.stringify(payload));
                const BATCH_SIZE = 900000;
                const totalLength = encryptedContent.length;
                
                const docRef = db.collection('users').doc(currentUser.uid).collection('memos').doc();
                const batch = db.batch();

                if (totalLength <= BATCH_SIZE) {
                    batch.set(docRef, {
                        content: encryptedContent,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        type: 'simple'
                    });
                } else {
                    const chunks = [];
                    for (let i = 0; i < totalLength; i += BATCH_SIZE) {
                        chunks.push(encryptedContent.substring(i, i + BATCH_SIZE));
                    }
                    batch.set(docRef, {
                        type: 'composite',
                        count: chunks.length,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    chunks.forEach((chunk, index) => {
                        const chunkRef = docRef.collection('chunks').doc(index.toString().padStart(3, '0'));
                        batch.set(chunkRef, { data: chunk });
                    });
                }

                await batch.commit();
                input.value = ""; // テキストボックスをクリア

            } catch (e) {
                console.error(e);
                alert("送信エラー: " + e.message);
            } finally {
                sendBtn.disabled = false;
                sendBtn.style.opacity = "1";
            }
        }

        // 描画の競合を防ぐための「整理券番号」
        let latestRenderId = 0;
        
        // 過去ログ読み込み用の管理変数
        let oldestDoc = null;      // 読み込んだ中で一番古いデータ
        let isLoadingOld = false;  // 読み込み中フラグ

        // --- メッセージ読み込み（一括表示＆ロード画面対応版） ---
        function loadMessages() {
            const container = document.getElementById('chat-container');
            const loadingScreen = document.getElementById('loading-screen');

            // ★読み込み開始時にロード画面を表示
            loadingScreen.style.display = 'flex';

            container.addEventListener('scroll', async () => {
                if (container.scrollTop === 0 && !isLoadingOld && oldestDoc) {
                    await loadOlderMessages();
                }
            });

            db.collection('users').doc(currentUser.uid).collection('memos')
                .orderBy('createdAt', 'desc') 
                .limit(5)
                .onSnapshot(async (snapshot) => {
                    const changes = snapshot.docChanges();
                    
                    // 今回の更新分を貯めておくバッファ（まだ画面には出しません）
                    const pendingElements = [];

                    if (snapshot.docs.length > 0) {
                        const lastDoc = snapshot.docs[snapshot.docs.length - 1];
                        if (!oldestDoc || lastDoc.data().createdAt < oldestDoc.data().createdAt) {
                            oldestDoc = lastDoc;
                        }
                    }

                    // 1. まずは裏ですべてのデータを処理・復号化する
                    for (const change of changes) {
                        if (change.type === "added") {
                            const doc = change.doc;
                            const data = doc.data();

                            if (document.getElementById(doc.id)) continue;

                            let payload = null;
                            try {
                                let encryptedString = "";
                                if (data.type === 'composite') {
                                    const chunksSnapshot = await doc.ref.collection('chunks').orderBy(firebase.firestore.FieldPath.documentId()).get();
                                    encryptedString = chunksSnapshot.docs.map(d => d.data().data).join('');
                                } else {
                                    encryptedString = data.content;
                                }

                                if (encryptedString) {
                                    const decryptedJSON = decryptData(encryptedString);
                                    if (decryptedJSON) {
                                        payload = JSON.parse(decryptedJSON);
                                    }
                                }
                            } catch (e) {
                                console.log("読み込みエラー:", e);
                                continue;
                            }

                            if (!payload) continue;

                            // 要素を作るだけ作って、バッファに入れる（まだ表示しない！）
                            
                            // 時刻データを計算して、関数に渡す
                            const ts = data.createdAt ? data.createdAt.toMillis() : Date.now();
                            const div = createMessageElement(payload, doc.id, ts); // 第3引数(ts)を追加
                            
                            div.dataset.timestamp = ts;
                            
                            pendingElements.push(div);
                        }
                    }

                    // 2. 準備ができたら、バッファの中身を一気に画面に追加する
                    if (pendingElements.length > 0) {
                        pendingElements.forEach(div => {
                            insertMessageInCorrectOrder(container, div);
                        });
                    }

                    // 3. 初回ロード時（ロード画面が出ている時）の仕上げ
                    if (loadingScreen.style.display !== 'none') {
                        // 一番下までスクロール
                        container.scrollTop = container.scrollHeight;
                        
                        // 少しだけ待ってから（画像の描画待ちなど）ロード画面を消す
                        setTimeout(() => {
                            loadingScreen.style.display = 'none';
                        }, 500); // 0.5秒余韻を持たせる（お好みで調整可）
                        
                        latestRenderId = 1;
                    }
                });
        }

        // --- 賢い挿入関数（日付を見て正しい場所に挟み込む） ---
        function insertMessageInCorrectOrder(container, newDiv) {
            const newTime = parseInt(newDiv.dataset.timestamp);
            const children = Array.from(container.children);

            // 1. コンテナが空ならそのまま追加
            if (children.length === 0) {
                container.appendChild(newDiv);
                return;
            }

            // 2. 一番下のメッセージ（最新）よりさらに新しいなら、一番下に追加
            const lastDiv = children[children.length - 1];
            if (newTime >= parseInt(lastDiv.dataset.timestamp)) {
                container.appendChild(newDiv);
                return;
            }

            // 3. 一番上のメッセージ（最古）より古いなら、一番上に追加
            const firstDiv = children[0];
            if (newTime <= parseInt(firstDiv.dataset.timestamp)) {
                container.insertBefore(newDiv, firstDiv);
                return;
            }

            // 4. それ以外（中間）の場合：下から順番に探して、自分より古いメッセージのすぐ上に挟む
            // （descで取得しているので、基本的には「上へ上へ」と追加されることが多いです）
            for (let i = children.length - 1; i >= 0; i--) {
                const child = children[i];
                const childTime = parseInt(child.dataset.timestamp);
                
                if (newTime > childTime) {
                    // 見つけた「自分より古いメッセージ」の「次（下）」に挿入したかったが...
                    // insertBeforeは「前」に入れる関数なので、i+1（自分より新しいメッセージ）の前に入れる
                    container.insertBefore(newDiv, children[i + 1]);
                    return;
                }
            }
            // ここに来ることは稀だが、念のため一番上へ
            container.insertBefore(newDiv, container.firstChild);
        }

        // --- 過去のメッセージを読み込む関数 ---
        async function loadOlderMessages() {
            if (isLoadingOld || !oldestDoc) return;
            isLoadingOld = true;

            const container = document.getElementById('chat-container');
            const previousHeight = container.scrollHeight; // ロード前の高さを記録

            try {
                // oldestDoc よりさらに古いデータを10件取得
                const snapshot = await db.collection('users').doc(currentUser.uid).collection('memos')
                    .orderBy('createdAt', 'desc')
                    .startAfter(oldestDoc)
                    .limit(5)
                    .get();

                if (!snapshot.empty) {
                    oldestDoc = snapshot.docs[snapshot.docs.length - 1];

                    for (const doc of snapshot.docs) {
                        if (document.getElementById(doc.id)) continue;

                        // データの復元（省略なし）
                        let payload = null;
                        try {
                            const data = doc.data();
                            let encryptedString = "";
                            if (data.type === 'composite') {
                                const chunksSnapshot = await doc.ref.collection('chunks').orderBy(firebase.firestore.FieldPath.documentId()).get();
                                encryptedString = chunksSnapshot.docs.map(d => d.data().data).join('');
                            } else {
                                encryptedString = data.content;
                            }
                            if (encryptedString) {
                                const decryptedJSON = decryptData(encryptedString);
                                if (decryptedJSON) payload = JSON.parse(decryptedJSON);
                            }
                        } catch(e) {}

                        if (payload) {
                            // 時刻データを計算して、関数に渡す
                            const ts = doc.data().createdAt ? doc.data().createdAt.toMillis() : 0;
                            const div = createMessageElement(payload, doc.id, ts); // 第3引数(ts)を追加
                            
                            div.dataset.timestamp = ts;
                            
                            insertMessageInCorrectOrder(container, div);
                        }
                    }

                    // スクロール位置の維持（ガクッとなるのを防ぐ）
                    // 新しく増えた高さの分だけスクロール位置をずらす
                    container.scrollTop = container.scrollHeight - previousHeight;
                }
            } catch (e) {
                console.error("過去ログ読み込みエラー:", e);
            } finally {
                isLoadingOld = false;
            }
        }

        // --- 画面表示（共通：要素を作るだけの関数・時刻外出し版） ---
        function createMessageElement(payload, docId, timestamp = null) {
            // 1. 全体を包む「行」を作る
            const row = document.createElement('div');
            row.className = 'message-row';
            if (docId) row.id = docId;

            // 2. 時刻を作る（左側に置くため、先に追加する）
            if (timestamp) {
                const timeSpan = document.createElement('span');
                timeSpan.className = 'timestamp';
                
                const date = new Date(timestamp);
                const hours = date.getHours().toString().padStart(2, '0');
                const minutes = date.getMinutes().toString().padStart(2, '0');
                
                const today = new Date();
                if (date.getDate() !== today.getDate() || date.getMonth() !== today.getMonth()) {
                    const month = date.getMonth() + 1;
                    const day = date.getDate();
                    timeSpan.innerText = `${month}/${day} ${hours}:${minutes}`;
                } else {
                    timeSpan.innerText = `${hours}:${minutes}`;
                }
                
                row.appendChild(timeSpan);
            }

            // 3. 吹き出し（バブル）を作る
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble'; // 新しいクラス名

            const images = payload.images || (payload.image ? [payload.image] : []);
            
            // 画像の表示
            if (images.length > 0) {
                const gridDiv = document.createElement('div');
                gridDiv.className = 'image-grid';
                gridDiv.setAttribute('data-count', images.length);
                images.forEach(src => {
                    const el = createMediaElement(src);
                    gridDiv.appendChild(el);
                });
                bubble.appendChild(gridDiv);
            }

            // テキストの表示
            if (payload.text) {
                const textDiv = document.createElement('div');
                textDiv.innerText = payload.text;
                // 画像がある場合は少し隙間を空ける
                if (images.length > 0) textDiv.style.marginTop = "5px";
                bubble.appendChild(textDiv);
            }

            // 4. 吹き出しを行に追加
            row.appendChild(bubble);

            return row; // 行ごと返す
        }

        // （共通部品）画像・動画タグを作る関数（クリック拡大対応版）
        function createMediaElement(src) {
            if (src.startsWith('data:video')) {
                const video = document.createElement('video');
                video.src = src;
                video.controls = true;
                // 動画はプレーヤーの機能で全画面にできるので、ここでの処理は不要
                return video;
            } else {
                const img = document.createElement('img');
                img.src = src;
                img.style.cursor = "pointer"; // クリックできることをカーソルで示す
                
                // 【追加】画像がクリックされたら拡大関数を呼ぶ
                img.onclick = function(e) {
                    // 親要素へのイベント伝播（バグの元）を防ぐ
                    e.stopPropagation(); 
                    openModal(src);
                };
                return img;
            }
        }

        // --- ズーム機能付きモーダル制御 ---
        
        const modal = document.getElementById('image-modal');
        const img = document.getElementById('modal-img');

        let state = {
            scale: 1,
            panning: false,
            pointX: 0,
            pointY: 0,
            startX: 0,
            startY: 0
        };

        // モーダルを開く
        function openModal(src) {
            img.src = src;
            modal.style.display = 'flex';
            
            // 初期化
            state = { scale: 1, panning: false, pointX: 0, pointY: 0, startX: 0, startY: 0 };
            updateTransform();

            // ★【追加】履歴に「画像を開いた」という状態を追加
            // これにより、スマホの「戻る」操作がこの履歴を消す動作になります
            history.pushState({ modalOpen: true }, null, null);
        }

        // モーダルを閉じる（左上の矢印ボタン用）
        function closeModal() {
            // 矢印ボタンが押されたら、ブラウザの「戻る」機能を発動させる
            // → これが下の 'popstate' イベントを呼び出し、そこで画面が閉じられます
            history.back();
        }

        // ★【追加】ブラウザの「戻る（スワイプ/ボタン）」を検知して閉じる処理
        window.addEventListener('popstate', () => {
            // 履歴が戻ったので、画面を非表示にする
            modal.style.display = 'none';
        });

        function updateTransform() {
            img.style.transform = `translate(${state.pointX}px, ${state.pointY}px) scale(${state.scale})`;
        }

        // --- タッチ操作のロジック ---
        let startDist = 0;
        let startScale = 1;

        // 1. タッチ開始
        modal.addEventListener('touchstart', (e) => {
            e.stopPropagation(); // 裏側への伝播防止

            if (e.touches.length === 2) {
                // ピンチ（ズーム）開始
                e.preventDefault();
                startDist = getDistance(e.touches[0], e.touches[1]);
                startScale = state.scale;
            } else if (e.touches.length === 1) {
                // パン（移動）開始
                state.panning = true;
                state.startX = e.touches[0].clientX - state.pointX;
                state.startY = e.touches[0].clientY - state.pointY;
            }
        });

        // 2. 指を動かしている時
        modal.addEventListener('touchmove', (e) => {
            e.preventDefault(); // 画面スクロール防止
            e.stopPropagation();

            if (e.touches.length === 2) {
                // --- ピンチ操作中 ---
                const dist = getDistance(e.touches[0], e.touches[1]);
                let newScale = startScale * (dist / startDist);
                
                // 中央吸着ロジック
                if (newScale < 1.1) {
                    newScale = 1;
                    state.pointX = 0;
                    state.pointY = 0;
                }

                // 最大拡大率
                if (newScale > 5) newScale = 5;

                state.scale = newScale;
                updateTransform();

            } else if (e.touches.length === 1 && state.panning && state.scale > 1) {
                // --- 移動操作中 ---
                state.pointX = e.touches[0].clientX - state.startX;
                state.pointY = e.touches[0].clientY - state.startY;
                updateTransform();
            }
        });

        // 3. 指を離した時
        modal.addEventListener('touchend', (e) => {
            e.stopPropagation();
            
            if (e.touches.length === 0) {
                state.panning = false;
                
                // 指を離した瞬間の吸着チェック
                if (state.scale < 1.1) {
                    state.scale = 1;
                    state.pointX = 0;
                    state.pointY = 0;
                    updateTransform();
                }
            }
        });
        
        // クリックイベントの防波堤
        modal.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // 補助関数：2点間の距離
        function getDistance(t1, t2) {
            const dx = t1.clientX - t2.clientX;
            const dy = t1.clientY - t2.clientY;
            return Math.sqrt(dx*dx + dy*dy);
        }

        // --- 自動ログイン監視機能 ---
        // ページを開いた時、以前のログイン状態が残っているかチェックします
        auth.onAuthStateChanged((user) => {
            const savedKey = localStorage.getItem('savedKey');

            if (user && savedKey) {
                // 【ログイン済みの場合】
                // モーダルは最初から display: none なので、消す処理は不要。
                // そのままアプリを開始するだけ。
                secretKey = savedKey;
                initApp(user);
            } else {
                // 【未ログインの場合】
                // ここではじめてログイン画面を表示する
                document.getElementById('auth-modal').style.display = 'flex';
            }
        });

        // --- ユーティリティ ---
        function handleKeyPress(e) {
            if (e.key === 'Enter') sendMessage();
        }

        // --- 画像ストック・送信ロジック（D&D対応版） ---

        // 送信待ちのファイルを溜めておく配列
        let stockedFiles = [];

        // 1. ファイル選択（ボタンから）
        function handleFileSelect(input) {
            if (input.files && input.files.length > 0) {
                // 配列に変換してストックに追加
                addFilesToStock(Array.from(input.files));
                input.value = ''; // 同じファイルを再度選べるようにリセット
            }
        }

        // 2. ドラッグ＆ドロップの処理
        const inputArea = document.getElementById('input-area');

        // ドラッグして重なった時
        inputArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            inputArea.classList.add('dragover'); // 色を変える
        });

        // ドラッグして離れた時
        inputArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            inputArea.classList.remove('dragover'); // 色を戻す
        });

        // ドロップした時
        inputArea.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            inputArea.classList.remove('dragover'); // 色を戻す
            
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                addFilesToStock(Array.from(e.dataTransfer.files));
            }
        });

        // --- 共通：ファイルをストックに追加してプレビュー更新 ---
        function addFilesToStock(files) {
            // 画像か動画だけをフィルタリング
            const validFiles = files.filter(file => file.type.startsWith('image/') || file.type.startsWith('video/'));
            
            if (validFiles.length === 0) return;

            // 配列に追加
            stockedFiles = stockedFiles.concat(validFiles);
            updatePreview();
        }

        // プレビュー画面の更新
        function updatePreview() {
            const previewArea = document.getElementById('preview-area');
            previewArea.innerHTML = ""; // 一旦クリア
            
            stockedFiles.forEach((file, index) => {
                const div = document.createElement('div');
                div.className = 'preview-item';
                
                // 画像を表示
                const img = document.createElement('img');
                img.src = URL.createObjectURL(file); // ブラウザ用の一時URLを作成
                
                // 削除ボタン（×）
                const btn = document.createElement('div');
                btn.className = 'preview-remove';
                btn.innerText = '×';
                btn.onclick = (e) => {
                    // 親要素へのクリック伝播を防ぐ（重要）
                    e.stopPropagation(); 
                    removeFile(index);
                };
                
                div.appendChild(img);
                div.appendChild(btn);
                previewArea.appendChild(div);
            });
        }

        // ストックから削除
        function removeFile(index) {
            stockedFiles.splice(index, 1); // 配列から削除
            updatePreview(); // 再描画
        }

        // --- 送信処理（ストックされた画像を処理するよう変更） ---
        async function sendMessage() {
            const input = document.getElementById('message-input');
            const text = input.value;
            
            // テキストも画像もなければ何もしない
            if (!text && stockedFiles.length === 0) return;

            const sendBtn = document.getElementById('send-btn');
            sendBtn.disabled = true;
            sendBtn.style.opacity = "0.5";

            try {
                // 1. ストックされている画像をデータURL（文字列）に一括変換
                let imagesData = [];
                if (stockedFiles.length > 0) {
                    const readPromises = stockedFiles.map(file => {
                        return new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.readAsDataURL(file);
                        });
                    });
                    // 全部の変換が終わるのを待つ
                    imagesData = await Promise.all(readPromises);
                }

                // 2. ペイロード作成
                const payload = {
                    text: text,
                    images: imagesData,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };

                // 3. 暗号化・分割保存（変更なし）
                const encryptedContent = encryptData(JSON.stringify(payload));
                const BATCH_SIZE = 900000;
                const totalLength = encryptedContent.length;
                
                const docRef = db.collection('users').doc(currentUser.uid).collection('memos').doc();
                const batch = db.batch();

                if (totalLength <= BATCH_SIZE) {
                    batch.set(docRef, {
                        content: encryptedContent,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        type: 'simple'
                    });
                } else {
                    const chunks = [];
                    for (let i = 0; i < totalLength; i += BATCH_SIZE) {
                        chunks.push(encryptedContent.substring(i, i + BATCH_SIZE));
                    }
                    batch.set(docRef, {
                        type: 'composite',
                        count: chunks.length,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    chunks.forEach((chunk, index) => {
                        const chunkRef = docRef.collection('chunks').doc(index.toString().padStart(3, '0'));
                        batch.set(chunkRef, { data: chunk });
                    });
                }

                await batch.commit();

                // 4. 送信完了後のリセット
                input.value = "";
                stockedFiles = []; // ストックを空にする
                updatePreview();   // プレビューを消す

            } catch (e) {
                console.error(e);
                alert("送信エラー: " + e.message);
            } finally {
                sendBtn.disabled = false;
                sendBtn.style.opacity = "1";
            }
        }

        function escapeHtml(str) {
            if(!str) return "";
            return str.replace(/[&<>'"]/g, 
                tag => ({
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    "'": '&#39;',
                    '"': '&quot;'
                }[tag]));
        }
    </script>
    
</body>
</html>
