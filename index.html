<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Secure Memo Transfer</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        /* LINE風 UIデザイン */
        :root {
            --bg-color: #7289DA; /* ディスコードとLINEの中間のような色 */
            --chat-bg: #85a0e6;
            --msg-bg-me: #8de055;
            --text-color: #333;
        }
        body { margin: 0; font-family: sans-serif; background-color: var(--chat-bg); height: 100vh; display: flex; flex-direction: column; }
        
        /* ヘッダー */
        header { background-color: #5d72a8; color: white; padding: 15px; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { margin: 0; font-size: 18px; }
        
        /* チャットエリア */
        #chat-container { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 10px; }
        
        .message { max-width: 80%; padding: 10px 15px; border-radius: 15px; font-size: 16px; line-height: 1.4; position: relative; word-break: break-all; }
        .message.self { align-self: flex-end; background-color: var(--msg-bg-me); color: var(--text-color); border-bottom-right-radius: 2px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .message img { max-width: 100%; border-radius: 10px; display: block; margin-top: 5px; cursor: pointer; }
        
        /* 入力エリア */
        #input-area { background: white; padding: 10px; display: flex; align-items: center; gap: 10px; border-top: 1px solid #ddd; }
        #message-input { flex: 1; padding: 12px; border-radius: 20px; border: 1px solid #ddd; outline: none; font-size: 16px; }
        #file-btn, #send-btn { background: none; border: none; cursor: pointer; color: #5d72a8; }
        #file-input { display: none; }

        /* 認証・設定モーダル */
        #auth-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background: white; padding: 25px; border-radius: 10px; width: 90%; max-width: 350px; text-align: center; }
        .modal-content input { width: 100%; padding: 10px; margin: 10px 0; box-sizing: border-box; }
        .modal-content button { width: 100%; padding: 12px; background: #5d72a8; color: white; border: none; border-radius: 5px; font-size: 16px; cursor: pointer; }
        .hidden { display: none !important; }

        /* --- 修正：画像タイル表示用のスタイル --- */
        .image-grid {
            display: grid;
            gap: 2px; /* 画像同士の隙間 */
            border-radius: 12px;
            overflow: hidden;
            max-width: 100%;
        }
        
        /* 枚数に応じてレイアウトを変える魔法 */
        .image-grid[data-count="1"] { grid-template-columns: 1fr; }
        .image-grid[data-count="2"] { grid-template-columns: 1fr 1fr; }
        .image-grid[data-count="3"] { grid-template-columns: 1fr 1fr 1fr; }
        .image-grid[data-count="4"] { grid-template-columns: 1fr 1fr; } /* 田の字 */
        .image-grid[data-count="5"] { grid-template-columns: 1fr 1fr 1fr; }
        .image-grid[data-count="6"] { grid-template-columns: 1fr 1fr 1fr; }
        /* 7枚以上は3列で折り返し */
        .image-grid[data-count="7"], .image-grid[data-count="8"], .image-grid[data-count="9"] { 
            grid-template-columns: repeat(3, 1fr); 
        }

        /* グリッド内の画像設定 */
        .image-grid img, .image-grid video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* 正方形に切り抜いて隙間を埋める */
            display: block;
            margin: 0 !important;
            border-radius: 0 !important; /* 角丸は親枠に任せる */
            aspect-ratio: 1 / 1; /* インスタのような正方形タイル */
            cursor: pointer;
        }

        /* 1枚だけの時は正方形にせず、元の比率で見せる */
        .image-grid[data-count="1"] img, .image-grid[data-count="1"] video {
            aspect-ratio: auto;
            max-height: 350px;
        }
    </style>
</head>
<body>

    <div id="auth-modal">
        <div class="modal-content">
            <h2>セキュリティ設定</h2>
            <p>このパスワードが暗号化キーになります。<br>忘れるとデータは復元できません。</p>
            <input type="email" id="email" placeholder="メールアドレス（ID代わり）">
            <input type="password" id="password" placeholder="ログインパスワード">
            <input type="password" id="encryption-key" placeholder="データ暗号化キー（必須）">
            <button onclick="login()">ログイン / 新規登録して開始</button>
        </div>
    </div>

    <header>
        <h1>Anzen Data Yuso</h1>
        <button onclick="logout()" style="background: transparent; border: 1px solid white; color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 14px;">
            ログアウト
        </button>
    </header>

    <div id="chat-container">
        </div>

    <div id="input-area">
        <label for="file-input" id="file-btn">
            <span class="material-icons" style="font-size: 30px;">add_photo_alternate</span>
        </label>
        <input type="file" id="file-input" accept="image/*,video/*" multiple onchange="handleFileSelect(this)">
        
        <input type="text" id="message-input" placeholder="メモを入力..." onkeypress="handleKeyPress(event)">
        
        <button id="send-btn" onclick="sendMessage()">
            <span class="material-icons" style="font-size: 30px;">send</span>
        </button>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

    <script>
        // 【重要】ここにあなたのFirebase設定を貼り付けてください
        // Firebase Console -> Project Settings -> General -> Your apps -> Config
        const firebaseConfig = {
            apiKey: "AIzaSyAST5jRP6cftYUHCb5MAtHr_H7SSht8mwA",
            authDomain: "anzendatayuso.firebaseapp.com",
            projectId: "anzendatayuso",
            storageBucket: "anzendatayuso.firebasestorage.app",
            messagingSenderId: "438096878174",
            appId: "1:438096878174:web:0c1867708a48af90ceb2cf"
        };

        // Firebase初期化
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.firestore();
        const auth = firebase.auth();
        let currentUser = null;
        let secretKey = ""; // ユーザーが入力した暗号化キー

        // --- 暗号化・復号化ロジック (AES) ---
        // サーバーにはこの関数を通した「意味不明な文字列」しか保存されません
        function encryptData(data) {
            return CryptoJS.AES.encrypt(data, secretKey).toString();
        }

        function decryptData(ciphertext) {
            try {
                const bytes = CryptoJS.AES.decrypt(ciphertext, secretKey);
                return bytes.toString(CryptoJS.enc.Utf8);
            } catch (e) {
                return null; // 復号失敗（キーが違うなど）
            }
        }

        // --- ログイン処理 ---
        function login() {
            const email = document.getElementById('email').value;
            const pass = document.getElementById('password').value;
            const key = document.getElementById('encryption-key').value;

            if (!email || !pass || !key) {
                alert("全ての項目を入力してください");
                return;
            }

            secretKey = key; // メモリ上にのみ保持

            // まずログインを試みる
            auth.signInWithEmailAndPassword(email, pass)
                .then((userCredential) => {
                    // ログイン成功
                    initApp(userCredential.user);
                })
                .catch((error) => {
                    // 失敗した場合の処理
                    // エラーコードが「ユーザー見つからない」や「認証情報無効（新規含む）」の場合、新規登録を試みる
                    const errorCode = error.code;
                    if (errorCode === 'auth/user-not-found' || 
                        errorCode === 'auth/invalid-login-credentials' || 
                        errorCode === 'auth/invalid-credential') {
                        
                        auth.createUserWithEmailAndPassword(email, pass)
                            .then((userCredential) => {
                                // 新規登録成功
                                initApp(userCredential.user);
                            })
                            .catch((createError) => {
                                // 新規登録も失敗した場合（＝すでにユーザーがいるがパスワードが違う場合など）
                                if (createError.code === 'auth/email-already-in-use') {
                                    alert("パスワードが間違っています。");
                                } else if (createError.code === 'auth/weak-password') {
                                    alert("パスワードは6文字以上にしてください。");
                                } else {
                                    alert("登録エラー: " + createError.message);
                                }
                            });
                    } else {
                        alert("ログインエラー: " + error.message);
                    }
                });
        }

        function initApp(user) {
            currentUser = user;
            document.getElementById('auth-modal').classList.add('hidden');
            loadMessages();
        }

        function logout() {
            auth.signOut();
            location.reload();
        }

        // --- メッセージ送信（分割アップロード機能付き） ---
        async function sendMessage(imageUrl = null) {
            const input = document.getElementById('message-input');
            const text = input.value;

            if (!text && !imageUrl) return;

            // 送信中であることを表示（簡易的）
            const sendBtn = document.getElementById('send-btn');
            sendBtn.disabled = true;
            sendBtn.style.opacity = "0.5";

            try {
                // 1. ペイロード作成
                const payload = {
                    text: text,
                    image: imageUrl, // オリジナルのBase64データ
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };

                // 2. 暗号化
                const encryptedContent = encryptData(JSON.stringify(payload));
                
                // 3. サイズチェックと分割保存
                const BATCH_SIZE = 900000; // 安全マージンをとって約900KBで分割
                const totalLength = encryptedContent.length;
                
                // メインのドキュメント参照を作成
                const docRef = db.collection('users').doc(currentUser.uid).collection('memos').doc();
                const batch = db.batch();

                if (totalLength <= BATCH_SIZE) {
                    // サイズが小さい場合は通常通り保存
                    batch.set(docRef, {
                        content: encryptedContent,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        type: 'simple'
                    });
                } else {
                    // サイズが大きい場合は分割保存
                    const chunks = [];
                    for (let i = 0; i < totalLength; i += BATCH_SIZE) {
                        chunks.push(encryptedContent.substring(i, i + BATCH_SIZE));
                    }

                    // メインデータには「分割されてますよ」という情報だけ書く
                    batch.set(docRef, {
                        type: 'composite', // 分割タイプ
                        count: chunks.length,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    // 分割したデータをサブコレクションに入れる
                    chunks.forEach((chunk, index) => {
                        const chunkRef = docRef.collection('chunks').doc(index.toString().padStart(3, '0'));
                        batch.set(chunkRef, { data: chunk });
                    });
                }

                await batch.commit();
                input.value = "";

            } catch (e) {
                console.error(e);
                alert("送信エラー: " + e.message);
            } finally {
                sendBtn.disabled = false;
                sendBtn.style.opacity = "1";
            }
        }

        // 描画の競合を防ぐための「整理券番号」
        let latestRenderId = 0;

        // --- メッセージ読み込み（最新50件のみ取得・高速化版） ---
        function loadMessages() {
            db.collection('users').doc(currentUser.uid).collection('memos')
                .orderBy('createdAt', 'asc') // 古い順に並べるが...
                .limitToLast(50)             // 【重要】最後の（最新の）50件だけを取得する制限
                .onSnapshot(async (snapshot) => {
                    const container = document.getElementById('chat-container');
                    const changes = snapshot.docChanges();

                    // 1つずつ順番に処理
                    for (const change of changes) {
                        if (change.type === "added") {
                            const doc = change.doc;
                            const data = doc.data();

                            // すでに表示済みならスキップ
                            if (document.getElementById(doc.id)) continue;

                            let encryptedString = "";
                            try {
                                if (data.type === 'composite') {
                                    // 分割データの結合
                                    const chunksSnapshot = await doc.ref.collection('chunks').orderBy(firebase.firestore.FieldPath.documentId()).get();
                                    encryptedString = chunksSnapshot.docs.map(d => d.data().data).join('');
                                } else {
                                    // 通常データ
                                    encryptedString = data.content;
                                }

                                if (!encryptedString) continue;

                                // 復号化
                                const decryptedJSON = decryptData(encryptedString);
                                if (!decryptedJSON) continue;

                                const payload = JSON.parse(decryptedJSON);

                                // 画面に追加
                                renderMessage(payload, doc.id);

                            } catch (e) {
                                console.log("読み込みエラー:", e);
                            }
                        }
                    }

                    // 読み込みが終わったら、即座に最新（一番下）を表示
                    // 処理が軽くなったので、待ち時間はほぼ不要ですが念のため微調整
                    setTimeout(() => {
                        container.scrollTop = container.scrollHeight;
                    }, 50);
                });
        }
        // --- 画面表示（LINE風まとめ表示機能付き） ---
        function renderMessage(payload, docId) {
            const container = document.getElementById('chat-container');
            const isMedia = !!payload.image; // 画像または動画か？
            
            // ★合体判定ロジック★
            // 1. 直前のメッセージを取得
            const lastMsg = container.lastElementChild;
            
            // 2. 合体できるかチェック
            let shouldMerge = false;
            if (lastMsg && isMedia) {
                // 直前も「画像グループ」で、かつ「自分のメッセージ」か確認
                const isLastGroup = lastMsg.classList.contains('media-group');
                // 時間差チェック（datasetに保存した時間と、今の時間の差が3秒以内なら同じグループとみなす）
                // ※簡易的に「直前の要素が存在すれば合体」としていますが、より厳密にするならタイムスタンプ比較も可能です
                if (isLastGroup) {
                     shouldMerge = true;
                }
            }

            // --- A. 合体する場合（前の吹き出しに追加） ---
            if (shouldMerge) {
                const grid = lastMsg.querySelector('.image-grid');
                const newItem = createMediaElement(payload.image);
                
                // グリッドに追加
                grid.appendChild(newItem);
                
                // データ属性（枚数）を更新 → CSSが反応してレイアウトが変わる
                const newCount = grid.children.length;
                grid.setAttribute('data-count', newCount);
                
                // IDを最新のものに更新しておく（既読管理などで使う場合のため）
                if (docId) lastMsg.id = docId;
            
            // --- B. 新しく吹き出しを作る場合 ---
            } else {
                const div = document.createElement('div');
                div.className = 'message self';
                if (docId) div.id = docId;

                let contentHtml = "";

                if (isMedia) {
                    // 画像・動画の場合：グリッドコンテナを作る
                    div.classList.add('media-group'); // 合体用の目印クラス
                    
                    const grid = document.createElement('div');
                    grid.className = 'image-grid';
                    grid.setAttribute('data-count', '1'); // 最初は1枚
                    
                    const item = createMediaElement(payload.image);
                    grid.appendChild(item);
                    div.appendChild(grid);
                    
                } else {
                    // テキストの場合
                    if (payload.text) {
                        contentHtml = `<div>${escapeHtml(payload.text)}</div>`;
                    }
                    div.innerHTML = contentHtml;
                }

                container.appendChild(div);
            }
        }

        // （共通部品）画像・動画タグを作る関数
        function createMediaElement(src) {
            if (src.startsWith('data:video')) {
                const video = document.createElement('video');
                video.src = src;
                video.controls = true;
                return video;
            } else {
                const img = document.createElement('img');
                img.src = src;
                // クリックしたら拡大などの処理はいったん省略
                return img;
            }
        }

        // --- ユーティリティ ---
        function handleKeyPress(e) {
            if (e.key === 'Enter') sendMessage();
        }

        // 画像・動画選択時の処理（複数枚・動画対応版）
        // 画像・動画選択時の処理（順序保証版）
        async function handleFileSelect(input) {
            if (input.files && input.files.length > 0) {
                // ファイル一覧を取得（選択した順序で並んでいます）
                const files = Array.from(input.files);
                
                // 誤操作防止のため通知
                alert(`${files.length}個のファイルを送信します。\n順番を保つため、少し時間をかけて送信します...`);

                // 1つずつ順番に処理して送信
                for (const file of files) {
                    await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = async function(e) {
                            try {
                                await sendMessage(e.target.result);
                                
                                // 【★ここが重要】次の送信まで0.5秒待つ
                                // これにより、確実に「作成日時」に差がつき、順番通りに並びます
                                await new Promise(r => setTimeout(r, 500)); 
                                
                                resolve(); 
                            } catch (err) {
                                console.error(err);
                                resolve(); 
                            }
                        };
                        reader.readAsDataURL(file);
                    });
                }
                
                alert("すべての送信が完了しました！");
            }
            // リセット
            input.value = '';
        }

        function escapeHtml(str) {
            if(!str) return "";
            return str.replace(/[&<>'"]/g, 
                tag => ({
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    "'": '&#39;',
                    '"': '&quot;'
                }[tag]));
        }
    </script>
</body>
</html>
