<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Secure Memo Transfer</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        /* LINE風 UIデザイン */
        :root {
            --bg-color: #7289DA; /* ディスコードとLINEの中間のような色 */
            --chat-bg: #85a0e6;
            --msg-bg-me: #8de055;
            --text-color: #333;
        }
        body { 
            margin: 0; 
            font-family: sans-serif; 
            background-color: var(--chat-bg); 
            
            /* 【重要変更】 100vh ではなく 100dvh にします */
            /* これでアドレスバーが動いても入力欄が画面外に消えなくなります */
            height: 100dvh; 
            
            display: flex; 
            flex-direction: column; 
            
            /* 画面全体がスクロールしてしまうのを防ぐ */
            overflow: hidden; 
        }
        
        /* ヘッダー */
        header { background-color: #5d72a8; color: white; padding: 15px; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { margin: 0; font-size: 18px; }
        
        /* チャットエリア */
        #chat-container { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 10px; }
        
        /* --- メッセージのレイアウト（LINE風：横並び） --- */
        /* 1つのメッセージの行（時間＋吹き出しを横に並べる） */
        .message-row {
            display: flex;
            justify-content: flex-end; /* 右寄せ */
            align-items: flex-end;     /* 下揃え */
            margin-bottom: 10px;       /* 次のメッセージとの間隔 */
            width: 100%;
        }

        /* 吹き出し本体 */
        .message-bubble {
            max-width: 70%;            /* 吹き出しの最大幅（少し狭める） */
            padding: 10px 15px;
            border-radius: 15px;
            font-size: 16px;
            line-height: 1.4;
            position: relative;
            word-break: break-all;
            
            /* 緑色のスタイル */
            background-color: var(--msg-bg-me);
            color: var(--text-color);
            border-bottom-right-radius: 2px; /* 右下の角だけ尖らせる */
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        /* 画像のスタイル調整 */
        .message-bubble img { 
            max-width: 100%; 
            border-radius: 10px; 
            display: block; 
            cursor: pointer; 
        }

        /* 時刻表示（吹き出しの左・外側に配置） */
        .timestamp {
            font-size: 10px;
            color: rgba(0,0,0,0.6);
            margin-right: 6px;  /* 吹き出しとの隙間 */
            margin-bottom: 2px; /* 下端の微調整 */
            flex-shrink: 0;     /* 時間が潰れないようにする */
            white-space: nowrap; /* 改行させない */
        }
        
        .message img { max-width: 100%; border-radius: 10px; display: block; margin-top: 5px; cursor: pointer; }
        
        /* 入力エリア（高さを広げてタップしやすく修正 + 固定強化） */
        #input-area { 
            background: white; 
            padding: 20px 15px; 
            display: flex; 
            align-items: center; 
            gap: 15px; 
            border-top: 1px solid #ddd; 
            padding-bottom: calc(20px + env(safe-area-inset-bottom));

            /* 【追加】ここから下を追加してください */
            flex-shrink: 0;   /* 画面が狭くなっても、ここだけは絶対につぶさない */
            position: relative; 
            z-index: 10;      /* 常に一番手前に表示 */
        }

        /* テキスト入力欄（こちらも大きくする） */
        #message-input { 
            flex: 1; 
            /* 内側の余白を増やしてタップ判定を大きく */
            padding: 15px; 
            border-radius: 30px; /* 丸みを強く */
            border: 1px solid #ddd; 
            outline: none; 
            font-size: 16px; 
        }
        
        #file-btn, #send-btn { background: none; border: none; cursor: pointer; color: #5d72a8; }
        #file-input { display: none; }

        /* 認証・設定モーダル */
        #auth-modal { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0,0,0,0.8); 
            
            /* 【変更】最初は隠しておく！ */
            display: none; 
            
            justify-content: center; 
            align-items: center; 
            z-index: 1000; 
        }
        .modal-content { background: white; padding: 25px; border-radius: 10px; width: 90%; max-width: 350px; text-align: center; }
        .modal-content input { width: 100%; padding: 10px; margin: 10px 0; box-sizing: border-box; }
        .modal-content button { width: 100%; padding: 12px; background: #5d72a8; color: white; border: none; border-radius: 5px; font-size: 16px; cursor: pointer; }
        .hidden { display: none !important; }

        /* 画像グリッドのスタイル */
        .image-grid {
            display: grid;
            gap: 2px;
            border-radius: 12px;
            overflow: hidden;
            width: 100%;
            max-width: 300px; /* バカでかくならないように制限 */
        }
        
        /* 枚数ごとのレイアウト定義 */
        .image-grid[data-count="1"] { grid-template-columns: 1fr; }
        .image-grid[data-count="2"] { grid-template-columns: 1fr 1fr; }
        .image-grid[data-count="3"] { grid-template-columns: 1fr 1fr 1fr; }
        .image-grid[data-count="4"] { grid-template-columns: 1fr 1fr; } /* 2x2 */
        
        /* 5枚以上は3列 */
        .image-grid[data-count="5"], .image-grid[data-count="6"], 
        .image-grid[data-count="7"], .image-grid[data-count="8"], 
        .image-grid[data-count="9"] { 
            grid-template-columns: repeat(3, 1fr); 
        }

        .image-grid img, .image-grid video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            aspect-ratio: 1 / 1; /* 正方形にする */
            display: block;
        }
        
        /* 1枚だけの時は正方形強制を解除 */
        .image-grid[data-count="1"] img, .image-grid[data-count="1"] video {
            aspect-ratio: auto;
            max-height: 400px;
        }

        /* ロード画面のスタイル */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #85a0e6; /* チャット背景と同じ色 */
            display: none; /* 最初はJSで制御するのでnoneにしておく */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* ログイン画面より手前 */
            color: white;
            font-weight: bold;
        }

        /* クルクル回るスピナー */
        .loader {
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top: 5px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- 追加：時刻表示のスタイル --- */
        .timestamp {
            display: block;          /* 改行して配置 */
            font-size: 10px;         /* 文字はかなり小さく */
            color: rgba(0,0,0,0.5);  /* 薄い黒色 */
            text-align: right;       /* 右寄せ */
            margin-top: 4px;         /* 画像や文字との隙間 */
            line-height: 1;          /* 行間を詰める */
        }
        
        /* 画像だけの場合は、画像の上に重ならないように少し調整 */
        .message .image-grid + .timestamp {
            margin-top: 6px;
        }
        
        /* モーダル内の画像にタッチ操作の設定を追加 */
        #modal-img {
            /* 既存のスタイル */
            max-width: 95%;
            max-height: 95%;
            object-fit: contain;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            
            /* 【追加】ここから下を追加してください */
            touch-action: none; /* ブラウザのデフォルト操作を無効化 */
            transform-origin: center center; /* 真ん中を中心に拡大 */
            transition: transform 0.1s ease-out; /* 動きを滑らかに */
        }

        /* モーダルの戻るボタン */
        #modal-back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 32px;       /* 大きくて押しやすく */
            padding: 12px;         /* タップ判定を広く */
            background: rgba(0, 0, 0, 0.5); /* 半透明の黒背景 */
            border-radius: 50%;    /* 丸くする */
            cursor: pointer;
            z-index: 10001;        /* 画像より手前に表示 */
            user-select: none;     /* 文字選択させない */
        }
        
        /* ボタンを押した時のリアクション */
        #modal-back-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        /* 背景の黒い幕に対する設定（裏側への貫通防止） */
        #image-modal {
            touch-action: none;
        }

        /* --- 画像プレビューとD&Dのスタイル --- */
        
        /* プレビューエリア（入力欄の上に表示） */
        #preview-area {
            display: flex;
            gap: 10px;
            padding: 0 10px;    /* 画像がある時だけ余白が出るようにJSで制御、またはmin-height */
            background: #f5f5f5;
            overflow-x: auto;   /* 横スクロール */
            border-top: 1px solid #ddd;
        }
        
        /* 画像が1枚もない時は隠す */
        #preview-area:empty {
            display: none;
            padding: 0;
            border: none;
        }

        /* サムネイルの枠 */
        .preview-item {
            position: relative;
            width: 60px;
            height: 60px;
            margin: 10px 0;
            border-radius: 5px;
            overflow: hidden;
            flex-shrink: 0;
            border: 1px solid #ccc;
            background: white;
        }

        .preview-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 削除ボタン（×） */
        .preview-remove {
            position: absolute;
            top: 0;
            right: 0;
            background: rgba(0,0,0,0.6);
            color: white;
            font-size: 14px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        /* ドラッグしてファイルを持ってきた時のハイライト */
        #input-area.dragover {
            background-color: #e0e7ff; /* 薄い青色 */
            border-top: 2px solid #5d72a8;
        }

        /* --- 長押しメニューのスタイル --- */
        
        /* 背景の暗幕 */
        .action-sheet-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.4);
            z-index: 20000; /* 画像モーダル(9999)より上 */
            display: none; /* 初期状態は非表示 */
            align-items: flex-end; /* 下に寄せる */
            justify-content: center;
        }

        /* メニュー本体 */
        .action-sheet {
            background: #f2f2f2;
            width: 95%;
            max-width: 400px;
            margin-bottom: 20px;
            border-radius: 13px;
            overflow: hidden;
            animation: slideUp 0.2s ease-out;
        }

        /* 各ボタン */
        .action-item {
            background: white;
            padding: 16px;
            text-align: center;
            font-size: 18px;
            color: #007aff; /* iOSっぽい青 */
            border-bottom: 1px solid #e0e0e0;
            cursor: pointer;
        }
        
        .action-item:last-child {
            border-bottom: none;
        }

        /* キャンセルボタンは少し太字で */
        .action-item.cancel {
            font-weight: bold;
            margin-top: 8px; /* 少し隙間をあける */
            border-radius: 13px;
        }

        /* 下から出てくるアニメーション */
        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }
        
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loader"></div>
        <p>ロード中...</p> </div>

    <div id="auth-modal">
        <div class="modal-content">
            <h2>セキュリティ設定</h2>
            <p>このパスワードが暗号化キーになります。<br>忘れるとデータは復元できません。</p>
            <input type="email" id="email" placeholder="メールアドレス（ID代わり）">
            <input type="password" id="password" placeholder="ログインパスワード">
            <input type="password" id="encryption-key" placeholder="データ暗号化キー（必須）">
            <button onclick="login()">ログイン / 新規登録して開始</button>
        </div>
    </div>

    <header>
        <h1>anzen datA YUSO</h1>
        <button onclick="logout()" style="background: transparent; border: 1px solid white; color: white; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 14px;">
            ログアウト
        </button>
    </header>

    <div id="chat-container"></div>

    <div id="preview-area"></div>

    <div id="input-area">
        <label for="file-input" id="file-btn">
            <span class="material-icons" style="font-size: 30px;">add_photo_alternate</span>
        </label>
        <input type="file" id="file-input" accept="image/*,video/*" multiple onchange="handleFileSelect(this)">
        
        <input type="text" id="message-input" placeholder="メモを入力..." onkeypress="handleKeyPress(event)">
        
        <button id="send-btn" onclick="sendMessage()">
            <span class="material-icons" style="font-size: 30px;">send</span>
        </button>
    </div>

    <div id="image-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 9999; justify-content: center; align-items: center;">
        <span id="modal-back-btn" class="material-icons" onclick="closeModal()">arrow_back</span>
        
        <img id="modal-img" style="max-width: 95%; max-height: 95%; object-fit: contain; box-shadow: 0 0 20px rgba(0,0,0,0.5);">
    </div>

    <div id="context-menu" class="action-sheet-overlay" onclick="closeContextMenu()">
        <div class="action-sheet">
            <div class="action-item" onclick="copyImage()">画像をコピー</div>
            <div class="action-item" onclick="downloadImage()">画像を保存</div>
            <div class="action-item cancel">キャンセル</div>
        </div>
    </div>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

    <script>
        // 【重要】ここにFirebase設定を貼り付ける
        // Firebase Console -> Project Settings -> General -> Your apps -> Config
        const firebaseConfig = {
            apiKey: "AIzaSyAST5jRP6cftYUHCb5MAtHr_H7SSht8mwA",
            authDomain: "anzendatayuso.firebaseapp.com",
            projectId: "anzendatayuso",
            storageBucket: "anzendatayuso.firebasestorage.app",
            messagingSenderId: "438096878174",
            appId: "1:438096878174:web:0c1867708a48af90ceb2cf"
        };

        // Firebase初期化
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.firestore();
        const auth = firebase.auth();
        let currentUser = null;
        let secretKey = ""; // ユーザーが入力した暗号化キー

        // --- 暗号化・復号化ロジック (AES) ---
        // サーバーにはこの関数を通した「意味不明な文字列」しか保存されません
        function encryptData(data) {
            return CryptoJS.AES.encrypt(data, secretKey).toString();
        }

        function decryptData(ciphertext) {
            try {
                const bytes = CryptoJS.AES.decrypt(ciphertext, secretKey);
                return bytes.toString(CryptoJS.enc.Utf8);
            } catch (e) {
                return null; // 復号失敗（キーが違うなど）
            }
        }

        // --- ログイン処理 ---
        function login() {
            const email = document.getElementById('email').value;
            const pass = document.getElementById('password').value;
            const key = document.getElementById('encryption-key').value;

            if (!email || !pass || !key) {
                alert("全ての項目を入力してください");
                return;
            }

            // 【追加】ここで鍵をブラウザに保存してしまう
            localStorage.setItem('savedKey', key); 
            secretKey = key; 

            // まずログインを試みる
            auth.signInWithEmailAndPassword(email, pass)
                .then((userCredential) => {
                    initApp(userCredential.user);
                })
                .catch((error) => {
                    // エラー処理（前回と同じロジック）
                    const errorCode = error.code;
                    if (errorCode === 'auth/user-not-found' || 
                        errorCode === 'auth/invalid-login-credentials' || 
                        errorCode === 'auth/invalid-credential') {
                        
                        auth.createUserWithEmailAndPassword(email, pass)
                            .then((userCredential) => {
                                initApp(userCredential.user);
                            })
                            .catch((createError) => {
                                if (createError.code === 'auth/email-already-in-use') {
                                    alert("パスワードが間違っています。");
                                } else if (createError.code === 'auth/weak-password') {
                                    alert("パスワードは6文字以上にしてください。");
                                } else {
                                    alert("登録エラー: " + createError.message);
                                }
                            });
                    } else {
                        alert("ログインエラー: " + error.message);
                    }
                });
        }

        function initApp(user) {
            currentUser = user;
            document.getElementById('auth-modal').classList.add('hidden');
            loadMessages();
        }

        function logout() {
            // ログアウト時は保存した鍵も消去する
            localStorage.removeItem('savedKey');
            auth.signOut();
            location.reload();
        }

        // --- メッセージ送信（複数枚セット対応版） ---
        async function sendMessage(textInput = null, imagesInput = null) {
            // テキストボックスの値を取得（引数がなければ）
            const input = document.getElementById('message-input');
            const text = textInput !== null ? textInput : input.value;
            
            // 画像配列の準備
            let images = [];
            if (imagesInput) {
                // 配列ならそのまま、単体なら配列にする（互換性のため）
                images = Array.isArray(imagesInput) ? imagesInput : [imagesInput];
            }

            if (!text && images.length === 0) return;

            const sendBtn = document.getElementById('send-btn');
            sendBtn.disabled = true;
            sendBtn.style.opacity = "0.5";

            try {
                // ペイロード作成（images配列を保存）
                const payload = {
                    text: text,
                    images: images, // ここに複数枚入る
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };

                // 暗号化・分割保存ロジック（変更なし、そのまま利用）
                const encryptedContent = encryptData(JSON.stringify(payload));
                const BATCH_SIZE = 900000;
                const totalLength = encryptedContent.length;
                
                const docRef = db.collection('users').doc(currentUser.uid).collection('memos').doc();
                const batch = db.batch();

                if (totalLength <= BATCH_SIZE) {
                    batch.set(docRef, {
                        content: encryptedContent,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        type: 'simple'
                    });
                } else {
                    const chunks = [];
                    for (let i = 0; i < totalLength; i += BATCH_SIZE) {
                        chunks.push(encryptedContent.substring(i, i + BATCH_SIZE));
                    }
                    batch.set(docRef, {
                        type: 'composite',
                        count: chunks.length,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    chunks.forEach((chunk, index) => {
                        const chunkRef = docRef.collection('chunks').doc(index.toString().padStart(3, '0'));
                        batch.set(chunkRef, { data: chunk });
                    });
                }

                await batch.commit();
                input.value = ""; // テキストボックスをクリア

            } catch (e) {
                console.error(e);
                alert("送信エラー: " + e.message);
            } finally {
                sendBtn.disabled = false;
                sendBtn.style.opacity = "1";
            }
        }

        // 描画の競合を防ぐための「整理券番号」
        let latestRenderId = 0;
        
        // 過去ログ読み込み用の管理変数
        let oldestDoc = null;      // 読み込んだ中で一番古いデータ
        let isLoadingOld = false;  // 読み込み中フラグ

        // --- メッセージ読み込み（3件ずつ読み込み・画面埋め合わせ対応版） ---
        function loadMessages() {
            const container = document.getElementById('chat-container');
            const loadingScreen = document.getElementById('loading-screen');

            loadingScreen.style.display = 'flex';

            container.addEventListener('scroll', async () => {
                if (container.scrollTop === 0 && !isLoadingOld && oldestDoc) {
                    await loadOlderMessages();
                }
            });

            db.collection('users').doc(currentUser.uid).collection('memos')
                .orderBy('createdAt', 'desc') 
                .limit(3)
                .onSnapshot(async (snapshot) => {
                    const changes = snapshot.docChanges();
                    const pendingElements = [];

                    if (snapshot.docs.length > 0) {
                        const lastDoc = snapshot.docs[snapshot.docs.length - 1];
                        if (!oldestDoc || lastDoc.data().createdAt < oldestDoc.data().createdAt) {
                            oldestDoc = lastDoc;
                        }
                    }

                    for (const change of changes) {
                        if (change.type === "added") {
                            const doc = change.doc;
                            const data = doc.data();
                            if (document.getElementById(doc.id)) continue;

                            let payload = null;
                            try {
                                let encryptedString = "";
                                if (data.type === 'composite') {
                                    const chunksSnapshot = await doc.ref.collection('chunks').orderBy(firebase.firestore.FieldPath.documentId()).get();
                                    encryptedString = chunksSnapshot.docs.map(d => d.data().data).join('');
                                } else {
                                    encryptedString = data.content;
                                }
                                if (encryptedString) {
                                    const decryptedJSON = decryptData(encryptedString);
                                    if (decryptedJSON) payload = JSON.parse(decryptedJSON);
                                }
                            } catch (e) {
                                console.log("読み込みエラー:", e);
                                continue;
                            }

                            if (!payload) continue;

                            const ts = data.createdAt ? data.createdAt.toMillis() : Date.now();
                            const div = createMessageElement(payload, doc.id, ts);
                            div.dataset.timestamp = ts;
                            pendingElements.push(div);
                        }
                    }

                    if (pendingElements.length > 0) {
                        pendingElements.forEach(div => {
                            insertMessageInCorrectOrder(container, div);
                        });
                    }

                    if (loadingScreen.style.display !== 'none') {
                        container.scrollTop = container.scrollHeight;
                        
                        setTimeout(() => {
                            loadingScreen.style.display = 'none';
                            
                            // 【★修正点】
                            // ロード画面を消した後、もしスクロールバーが出ていなければ（画面が埋まってなければ）
                            // 強制的に過去ログを読み込みに行く
                            if (container.scrollHeight <= container.clientHeight && oldestDoc) {
                                loadOlderMessages();
                            }
                        }, 500);
                        
                        latestRenderId = 1;
                    }
                });
        }

        // --- 賢い挿入関数（日付を見て正しい場所に挟み込む） ---
        function insertMessageInCorrectOrder(container, newDiv) {
            const newTime = parseInt(newDiv.dataset.timestamp);
            const children = Array.from(container.children);

            // 1. コンテナが空ならそのまま追加
            if (children.length === 0) {
                container.appendChild(newDiv);
                return;
            }

            // 2. 一番下のメッセージ（最新）よりさらに新しいなら、一番下に追加
            const lastDiv = children[children.length - 1];
            if (newTime >= parseInt(lastDiv.dataset.timestamp)) {
                container.appendChild(newDiv);
                return;
            }

            // 3. 一番上のメッセージ（最古）より古いなら、一番上に追加
            const firstDiv = children[0];
            if (newTime <= parseInt(firstDiv.dataset.timestamp)) {
                container.insertBefore(newDiv, firstDiv);
                return;
            }

            // 4. それ以外（中間）の場合：下から順番に探して、自分より古いメッセージのすぐ上に挟む
            // （descで取得しているので、基本的には「上へ上へ」と追加されることが多いです）
            for (let i = children.length - 1; i >= 0; i--) {
                const child = children[i];
                const childTime = parseInt(child.dataset.timestamp);
                
                if (newTime > childTime) {
                    // 見つけた「自分より古いメッセージ」の「次（下）」に挿入したかったが...
                    // insertBeforeは「前」に入れる関数なので、i+1（自分より新しいメッセージ）の前に入れる
                    container.insertBefore(newDiv, children[i + 1]);
                    return;
                }
            }
            // ここに来ることは稀だが、念のため一番上へ
            container.insertBefore(newDiv, container.firstChild);
        }

        // --- 過去のメッセージを読み込む関数（2件ずつ・再帰的埋め合わせ対応版） ---
        async function loadOlderMessages() {
            if (isLoadingOld || !oldestDoc) return;
            isLoadingOld = true;

            const container = document.getElementById('chat-container');
            const previousHeight = container.scrollHeight; 

            try {
                // oldestDoc よりさらに古いデータを2件取得
                const snapshot = await db.collection('users').doc(currentUser.uid).collection('memos')
                    .orderBy('createdAt', 'desc')
                    .startAfter(oldestDoc)
                    .limit(2) // 【変更】ここを3から2に変更しました
                    .get();

                if (!snapshot.empty) {
                    oldestDoc = snapshot.docs[snapshot.docs.length - 1];

                    for (const doc of snapshot.docs) {
                        if (document.getElementById(doc.id)) continue;

                        let payload = null;
                        try {
                            const data = doc.data();
                            let encryptedString = "";
                            if (data.type === 'composite') {
                                const chunksSnapshot = await doc.ref.collection('chunks').orderBy(firebase.firestore.FieldPath.documentId()).get();
                                encryptedString = chunksSnapshot.docs.map(d => d.data().data).join('');
                            } else {
                                encryptedString = data.content;
                            }
                            if (encryptedString) {
                                const decryptedJSON = decryptData(encryptedString);
                                if (decryptedJSON) payload = JSON.parse(decryptedJSON);
                            }
                        } catch(e) {}

                        if (payload) {
                            const ts = doc.data().createdAt ? doc.data().createdAt.toMillis() : 0;
                            const div = createMessageElement(payload, doc.id, ts);
                            div.dataset.timestamp = ts;
                            insertMessageInCorrectOrder(container, div);
                        }
                    }

                    container.scrollTop = container.scrollHeight - previousHeight;
                }
            } catch (e) {
                console.error("過去ログ読み込みエラー:", e);
            } finally {
                isLoadingOld = false;

                // 読み込みが終わった後、まだ画面の高さに足りずスクロールバーが出ていないなら
                // さらにもう2件読み込みに行く（スクロールバーが出るまで繰り返す）
                if (container.scrollHeight <= container.clientHeight && oldestDoc) {
                    loadOlderMessages();
                }
            }
        }

        // --- 画面表示（共通：要素を作るだけの関数・時刻外出し版） ---
        function createMessageElement(payload, docId, timestamp = null) {
            // 1. 全体を包む「行」を作る
            const row = document.createElement('div');
            row.className = 'message-row';
            if (docId) row.id = docId;

            // 2. 時刻を作る（左側に置くため、先に追加する）
            if (timestamp) {
                const timeSpan = document.createElement('span');
                timeSpan.className = 'timestamp';
                
                const date = new Date(timestamp);
                const hours = date.getHours().toString().padStart(2, '0');
                const minutes = date.getMinutes().toString().padStart(2, '0');
                
                const today = new Date();
                if (date.getDate() !== today.getDate() || date.getMonth() !== today.getMonth()) {
                    const month = date.getMonth() + 1;
                    const day = date.getDate();
                    timeSpan.innerText = `${month}/${day} ${hours}:${minutes}`;
                } else {
                    timeSpan.innerText = `${hours}:${minutes}`;
                }
                
                row.appendChild(timeSpan);
            }

            // 3. 吹き出し（バブル）を作る
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble'; // 新しいクラス名

            const images = payload.images || (payload.image ? [payload.image] : []);
            
            // 画像の表示
            if (images.length > 0) {
                const gridDiv = document.createElement('div');
                gridDiv.className = 'image-grid';
                gridDiv.setAttribute('data-count', images.length);
                images.forEach(src => {
                    const el = createMediaElement(src);
                    gridDiv.appendChild(el);
                });
                bubble.appendChild(gridDiv);
            }

            // テキストの表示
            if (payload.text) {
                const textDiv = document.createElement('div');
                textDiv.innerText = payload.text;
                // 画像がある場合は少し隙間を空ける
                if (images.length > 0) textDiv.style.marginTop = "5px";
                bubble.appendChild(textDiv);
            }

            // 4. 吹き出しを行に追加
            row.appendChild(bubble);

            return row; // 行ごと返す
        }

        // （共通部品）画像・動画タグを作る関数（クリック拡大・長押し保存対応版）
        function createMediaElement(src) {
            if (src.startsWith('data:video')) {
                const video = document.createElement('video');
                video.src = src;
                video.controls = true;
                return video;
            } else {
                const img = document.createElement('img');
                img.src = src;
                img.style.cursor = "pointer";
                
                // --- サムネイルの長押し判定 ---
                let thumbTimer = null;

                img.addEventListener('touchstart', (e) => {
                    // 長押しタイマー開始 (600ms)
                    thumbTimer = setTimeout(() => {
                        openContextMenu(src); // メニューを開く
                        thumbTimer = null;    // タイマーリセット
                    }, 600);
                });

                img.addEventListener('touchmove', () => {
                    // 指が動いたらキャンセル（スクロール時はメニューを出さない）
                    if (thumbTimer) {
                        clearTimeout(thumbTimer);
                        thumbTimer = null;
                    }
                });

                img.addEventListener('touchend', () => {
                    // 指を離したらキャンセル
                    if (thumbTimer) {
                        clearTimeout(thumbTimer);
                        thumbTimer = null;
                    }
                });
                
                // --- クリックで拡大 ---
                img.onclick = function(e) {
                    e.stopPropagation();
                    // メニューが開いていない時だけ拡大する
                    // (長押し成立時はメニューが出るので、ここはスルーさせる意図)
                    if (document.getElementById('context-menu').style.display !== 'flex') {
                        openModal(src);
                    }
                };
                return img;
            }
        }

        // --- ズーム機能付きモーダル制御 ---
        
        const modal = document.getElementById('image-modal');
        const img = document.getElementById('modal-img');

        let state = {
            scale: 1,
            panning: false,
            pointX: 0,
            pointY: 0,
            startX: 0,
            startY: 0
        };

        // モーダルを開く
        function openModal(src) {
            img.src = src;
            modal.style.display = 'flex';
            
            // 初期化
            state = { scale: 1, panning: false, pointX: 0, pointY: 0, startX: 0, startY: 0 };
            updateTransform();

            // ★【追加】履歴に「画像を開いた」という状態を追加
            // これにより、スマホの「戻る」操作がこの履歴を消す動作になります
            history.pushState({ modalOpen: true }, null, null);
        }

        // モーダルを閉じる（左上の矢印ボタン用）
        function closeModal() {
            // 矢印ボタンが押されたら、ブラウザの「戻る」機能を発動させる
            // → これが下の 'popstate' イベントを呼び出し、そこで画面が閉じられます
            history.back();
        }

        // ★【追加】ブラウザの「戻る（スワイプ/ボタン）」を検知して閉じる処理
        window.addEventListener('popstate', () => {
            // 履歴が戻ったので、画面を非表示にする
            modal.style.display = 'none';
        });

        function updateTransform() {
            img.style.transform = `translate(${state.pointX}px, ${state.pointY}px) scale(${state.scale})`;
        }

        // --- タッチ操作のロジック ---
        let startDist = 0;
        let startScale = 1;
        
        // 長押し判定用のタイマー変数
        let longPressTimer = null;

        // 1. タッチ開始
        modal.addEventListener('touchstart', (e) => {
            e.stopPropagation();

            if (e.touches.length === 2) {
                // 指が2本なら長押し判定中止
                clearTimeout(longPressTimer);
                
                e.preventDefault();
                startDist = getDistance(e.touches[0], e.touches[1]);
                startScale = state.scale;
            } else if (e.touches.length === 1) {
                // パン（移動）開始
                state.panning = true;
                state.startX = e.touches[0].clientX - state.pointX;
                state.startY = e.touches[0].clientY - state.pointY;

                // 長押しタイマーを開始
                longPressTimer = setTimeout(() => {
                    // ★修正：現在の拡大画像のsrcを渡す
                    openContextMenu(img.src); 
                    state.panning = false;
                }, 600);
            }
        });

        // 2. 指を動かしている時
        modal.addEventListener('touchmove', (e) => {
            e.preventDefault();
            e.stopPropagation();

            // ★【追加】指が動いたら長押しではないのでタイマー解除
            // (数ピクセルのブレは許容するロジックも組めますが、今回は即解除で誤爆を防ぎます)
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }

            if (e.touches.length === 2) {
                // --- ピンチ操作中 ---
                const dist = getDistance(e.touches[0], e.touches[1]);
                let newScale = startScale * (dist / startDist);
                
                if (newScale < 1.1) {
                    newScale = 1;
                    state.pointX = 0;
                    state.pointY = 0;
                }
                if (newScale > 5) newScale = 5;

                state.scale = newScale;
                updateTransform();

            } else if (e.touches.length === 1 && state.panning && state.scale > 1) {
                // --- 移動操作中 ---
                state.pointX = e.touches[0].clientX - state.startX;
                state.pointY = e.touches[0].clientY - state.startY;
                updateTransform();
            }
        });

        // 3. 指を離した時
        modal.addEventListener('touchend', (e) => {
            e.stopPropagation();
            
            // ★【追加】指を離したら長押しタイマー解除
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
            
            if (e.touches.length === 0) {
                state.panning = false;
                
                // 吸着ロジック
                if (state.scale < 1.1) {
                    state.scale = 1;
                    state.pointX = 0;
                    state.pointY = 0;
                    updateTransform();
                }
            }
        });
        
        // クリックイベントの防波堤
        modal.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // 補助関数：2点間の距離
        function getDistance(t1, t2) {
            const dx = t1.clientX - t2.clientX;
            const dy = t1.clientY - t2.clientY;
            return Math.sqrt(dx*dx + dy*dy);
        }

        // --- 長押しメニューの制御 ---
        
        let targetDownloadSrc = ""; // 対象の画像を記憶

        function openContextMenu(src) {
            targetDownloadSrc = src;
            document.getElementById('context-menu').style.display = 'flex';
        }

        function closeContextMenu() {
            document.getElementById('context-menu').style.display = 'none';
            targetDownloadSrc = ""; 
        }

        // 画像をクリップボードにコピーする機能（Brave/Android対応）
        async function copyImage() {
            if (!targetDownloadSrc) return;
            
            closeContextMenu(); // メニューを閉じる

            // --- プランA：キャンバスを使って綺麗にPNG変換してコピー ---
            try {
                const img = new Image();
                // ★修正点：ここにあった crossOrigin の行を削除しました（読み込みエラー対策）
                img.src = targetDownloadSrc;
                
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = () => reject(new Error("画像の読み込みエラー"));
                });

                const canvas = document.createElement('canvas');
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                // キャンバスからPNGデータを取得（Promise化）
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));

                if (!blob) {
                    throw new Error("キャンバス処理がブロックされました"); // Braveなどで起きる
                }

                await navigator.clipboard.write([
                    new ClipboardItem({ "image/png": blob })
                ]);
                alert("画像をコピーしました");

            } catch (e) {
                console.log("プランA失敗:", e);

                // --- プランB：変換せずに元のデータをそのままコピー（Brave救済策） ---
                try {
                    const response = await fetch(targetDownloadSrc);
                    const blob = await response.blob();
                    
                    await navigator.clipboard.write([
                        new ClipboardItem({ [blob.type]: blob })
                    ]);
                    alert("画像をコピーしました");
                    
                } catch (err2) {
                    console.error(err2);
                    alert("コピーに失敗しました。\n※Brave等の場合、アドレスバーのライオンアイコンから「シールド」を一時的にOFFにすると動作する場合があります。");
                }
            }
        }

        // 画像を保存する機能
        function downloadImage() {
            if (!targetDownloadSrc) return;

            const link = document.createElement('a');
            const timestamp = new Date().getTime();
            link.href = targetDownloadSrc;
            link.download = `image_${timestamp}.png`;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            closeContextMenu();
        }
        
        // --- 自動ログイン監視機能 ---
        // ページを開いた時、以前のログイン状態が残っているかチェックします
        auth.onAuthStateChanged((user) => {
            const savedKey = localStorage.getItem('savedKey');

            if (user && savedKey) {
                // 【ログイン済みの場合】
                // モーダルは最初から display: none なので、消す処理は不要。
                // そのままアプリを開始するだけ。
                secretKey = savedKey;
                initApp(user);
            } else {
                // 【未ログインの場合】
                // ここではじめてログイン画面を表示する
                document.getElementById('auth-modal').style.display = 'flex';
            }
        });

        // --- ユーティリティ ---
        function handleKeyPress(e) {
            if (e.key === 'Enter') sendMessage();
        }

        // --- 画像ストック・送信ロジック（D&D対応版） ---

        // 送信待ちのファイルを溜めておく配列
        let stockedFiles = [];

        // 1. ファイル選択（ボタンから）
        function handleFileSelect(input) {
            if (input.files && input.files.length > 0) {
                // 配列に変換してストックに追加
                addFilesToStock(Array.from(input.files));
                input.value = ''; // 同じファイルを再度選べるようにリセット
            }
        }

        // 2. ドラッグ＆ドロップの処理
        const inputArea = document.getElementById('input-area');

        // ドラッグして重なった時
        inputArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            inputArea.classList.add('dragover'); // 色を変える
        });

        // ドラッグして離れた時
        inputArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            inputArea.classList.remove('dragover'); // 色を戻す
        });

        // ドロップした時
        inputArea.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            inputArea.classList.remove('dragover'); // 色を戻す
            
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                addFilesToStock(Array.from(e.dataTransfer.files));
            }
        });

        // --- 共通：ファイルをストックに追加してプレビュー更新 ---
        function addFilesToStock(files) {
            // 画像か動画だけをフィルタリング
            const validFiles = files.filter(file => file.type.startsWith('image/') || file.type.startsWith('video/'));
            
            if (validFiles.length === 0) return;

            // 配列に追加
            stockedFiles = stockedFiles.concat(validFiles);
            updatePreview();
        }

        // プレビュー画面の更新
        function updatePreview() {
            const previewArea = document.getElementById('preview-area');
            previewArea.innerHTML = ""; // 一旦クリア
            
            stockedFiles.forEach((file, index) => {
                const div = document.createElement('div');
                div.className = 'preview-item';
                
                // 画像を表示
                const img = document.createElement('img');
                img.src = URL.createObjectURL(file); // ブラウザ用の一時URLを作成
                
                // 削除ボタン（×）
                const btn = document.createElement('div');
                btn.className = 'preview-remove';
                btn.innerText = '×';
                btn.onclick = (e) => {
                    // 親要素へのクリック伝播を防ぐ（重要）
                    e.stopPropagation(); 
                    removeFile(index);
                };
                
                div.appendChild(img);
                div.appendChild(btn);
                previewArea.appendChild(div);
            });
        }

        // ストックから削除
        function removeFile(index) {
            stockedFiles.splice(index, 1); // 配列から削除
            updatePreview(); // 再描画
        }

        // --- 送信処理（ストックされた画像を処理するよう変更） ---
        async function sendMessage() {
            const input = document.getElementById('message-input');
            const text = input.value;
            
            // テキストも画像もなければ何もしない
            if (!text && stockedFiles.length === 0) return;

            const sendBtn = document.getElementById('send-btn');
            sendBtn.disabled = true;
            sendBtn.style.opacity = "0.5";

            try {
                // 1. ストックされている画像をデータURL（文字列）に一括変換
                let imagesData = [];
                if (stockedFiles.length > 0) {
                    const readPromises = stockedFiles.map(file => {
                        return new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.readAsDataURL(file);
                        });
                    });
                    // 全部の変換が終わるのを待つ
                    imagesData = await Promise.all(readPromises);
                }

                // 2. ペイロード作成
                const payload = {
                    text: text,
                    images: imagesData,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };

                // 3. 暗号化・分割保存（変更なし）
                const encryptedContent = encryptData(JSON.stringify(payload));
                const BATCH_SIZE = 900000;
                const totalLength = encryptedContent.length;
                
                const docRef = db.collection('users').doc(currentUser.uid).collection('memos').doc();
                const batch = db.batch();

                if (totalLength <= BATCH_SIZE) {
                    batch.set(docRef, {
                        content: encryptedContent,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        type: 'simple'
                    });
                } else {
                    const chunks = [];
                    for (let i = 0; i < totalLength; i += BATCH_SIZE) {
                        chunks.push(encryptedContent.substring(i, i + BATCH_SIZE));
                    }
                    batch.set(docRef, {
                        type: 'composite',
                        count: chunks.length,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    chunks.forEach((chunk, index) => {
                        const chunkRef = docRef.collection('chunks').doc(index.toString().padStart(3, '0'));
                        batch.set(chunkRef, { data: chunk });
                    });
                }

                await batch.commit();

                // 4. 送信完了後のリセット
                input.value = "";
                stockedFiles = []; // ストックを空にする
                updatePreview();   // プレビューを消す

            } catch (e) {
                console.error(e);
                alert("送信エラー: " + e.message);
            } finally {
                sendBtn.disabled = false;
                sendBtn.style.opacity = "1";
            }
        }

        function escapeHtml(str) {
            if(!str) return "";
            return str.replace(/[&<>'"]/g, 
                tag => ({
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    "'": '&#39;',
                    '"': '&quot;'
                }[tag]));
        }
    </script>
    
</body>
</html>
